fn heartbeat (s: [u8; 21]) -> Result<(), isize> 
{
    const PADDING: usize = 16;
    let mut p = s;
    let hbtype:u8 = p[0];
    let payload:usize = ((p[1] as usize) << 8) + p[2] as usize; 

   // let mut buffer: [u8;payload+PADDING]; //needs constant size of array

   let mut buffer: [u8;15] = [0;15];
   buffer = &s[2..21];
   buffer = &mut p;
   buffer.copy_from_slice(&s);
   
    //buffer.extend(p[1..1+2].iter().cloned());  // copy of payload string happens here. Even in this case there is no previous boundary checking.               
    //buffer.extend(p[3..3+payload].iter().cloned());             
    /*
    let mut rng = mem::rand::thread_rng();                           
    buffer.extend( (0..PADDING).map(|_|rng.gen::<u8>())
			.collect::<Vec<u8>>() );
            */
/*
    if hbtype == TLS1_HB_REQUEST {
        let r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, &*buffer);
        return r
    }
    */
    Ok(())
}