<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="UART receiver control"><meta name="keywords" content="rust, rustlang, rust-lang, uart_rx_ctrl"><title>psoc6_01_pac::scb0::uart_rx_ctrl - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings"></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../psoc6_01_pac/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module uart_rx_ctrl</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li></ul></div><div id="sidebar-vars" data-name="uart_rx_ctrl" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img src="../../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">psoc6_01_pac</a>::<wbr><a href="../index.html">scb0</a>::<wbr><a class="mod" href="#">uart_rx_ctrl</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/psoc6_01_pac/scb0/uart_rx_ctrl.rs.html#1-506" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>UART receiver control</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.BREAK_WIDTH_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::BREAK_WIDTH_R struct">BREAK_WIDTH_R</a></td><td class="docblock-short"><p>Field <code>BREAK_WIDTH</code> reader - Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is ‘0’. This feature is useful for standard UART submode and LIN submode (‘break field’ detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to ‘1’. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver’s definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive ‘0’ bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive ‘0’ bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.BREAK_WIDTH_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::BREAK_WIDTH_W struct">BREAK_WIDTH_W</a></td><td class="docblock-short"><p>Field <code>BREAK_WIDTH</code> writer - Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is ‘0’. This feature is useful for standard UART submode and LIN submode (‘break field’ detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to ‘1’. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver’s definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive ‘0’ bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive ‘0’ bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DROP_ON_FRAME_ERROR_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::DROP_ON_FRAME_ERROR_R struct">DROP_ON_FRAME_ERROR_R</a></td><td class="docblock-short"><p>Field <code>DROP_ON_FRAME_ERROR</code> reader - Behavior when an error is detected in a start or stop period. When ‘0’, received data is send to the RX FIFO. When ‘1’, received data is dropped and lost.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DROP_ON_FRAME_ERROR_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::DROP_ON_FRAME_ERROR_W struct">DROP_ON_FRAME_ERROR_W</a></td><td class="docblock-short"><p>Field <code>DROP_ON_FRAME_ERROR</code> writer - Behavior when an error is detected in a start or stop period. When ‘0’, received data is send to the RX FIFO. When ‘1’, received data is dropped and lost.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DROP_ON_PARITY_ERROR_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::DROP_ON_PARITY_ERROR_R struct">DROP_ON_PARITY_ERROR_R</a></td><td class="docblock-short"><p>Field <code>DROP_ON_PARITY_ERROR</code> reader - Behavior when a parity check fails. When ‘0’, received data is send to the RX FIFO. When ‘1’, received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DROP_ON_PARITY_ERROR_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::DROP_ON_PARITY_ERROR_W struct">DROP_ON_PARITY_ERROR_W</a></td><td class="docblock-short"><p>Field <code>DROP_ON_PARITY_ERROR</code> writer - Behavior when a parity check fails. When ‘0’, received data is send to the RX FIFO. When ‘1’, received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.LIN_MODE_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::LIN_MODE_R struct">LIN_MODE_R</a></td><td class="docblock-short"><p>Field <code>LIN_MODE</code> reader - Only applicable in standard UART submode. When ‘1’, the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of ‘0’. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to ‘1’. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to ‘1’ (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.LIN_MODE_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::LIN_MODE_W struct">LIN_MODE_W</a></td><td class="docblock-short"><p>Field <code>LIN_MODE</code> writer - Only applicable in standard UART submode. When ‘1’, the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of ‘0’. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to ‘1’. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to ‘1’ (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.MP_MODE_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::MP_MODE_R struct">MP_MODE_R</a></td><td class="docblock-short"><p>Field <code>MP_MODE</code> reader - Multi-processor mode. When ‘1’, multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame separates addresses (bit is ‘1’) from data (bit is ‘0’). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.MP_MODE_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::MP_MODE_W struct">MP_MODE_W</a></td><td class="docblock-short"><p>Field <code>MP_MODE</code> writer - Multi-processor mode. When ‘1’, multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame separates addresses (bit is ‘1’) from data (bit is ‘0’). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PARITY_ENABLED_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::PARITY_ENABLED_R struct">PARITY_ENABLED_R</a></td><td class="docblock-short"><p>Field <code>PARITY_ENABLED</code> reader - Parity checking enabled (‘1’) or not (‘0’). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PARITY_ENABLED_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::PARITY_ENABLED_W struct">PARITY_ENABLED_W</a></td><td class="docblock-short"><p>Field <code>PARITY_ENABLED</code> writer - Parity checking enabled (‘1’) or not (‘0’). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PARITY_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::PARITY_R struct">PARITY_R</a></td><td class="docblock-short"><p>Field <code>PARITY</code> reader - Parity bit. When ‘0’, the receiver expects an even parity. When ‘1’, the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PARITY_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::PARITY_W struct">PARITY_W</a></td><td class="docblock-short"><p>Field <code>PARITY</code> writer - Parity bit. When ‘0’, the receiver expects an even parity. When ‘1’, the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.POLARITY_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::POLARITY_R struct">POLARITY_R</a></td><td class="docblock-short"><p>Field <code>POLARITY</code> reader - Inverts incoming RX line signal ‘uart_rx_in’. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.POLARITY_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::POLARITY_W struct">POLARITY_W</a></td><td class="docblock-short"><p>Field <code>POLARITY</code> writer - Inverts incoming RX line signal ‘uart_rx_in’. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::R struct">R</a></td><td class="docblock-short"><p>Register <code>UART_RX_CTRL</code> reader</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SKIP_START_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::SKIP_START_R struct">SKIP_START_R</a></td><td class="docblock-short"><p>Field <code>SKIP_START</code> reader - Only applicable in standard UART submode. When ‘1’, the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a ‘1’. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle (‘1’) to START (‘0’) on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB’s UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a ‘0’ to ‘1’ transition, which indicates the first data frame bit is received (first data frame bit should be ‘1’). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SKIP_START_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::SKIP_START_W struct">SKIP_START_W</a></td><td class="docblock-short"><p>Field <code>SKIP_START</code> writer - Only applicable in standard UART submode. When ‘1’, the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a ‘1’. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle (‘1’) to START (‘0’) on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB’s UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a ‘0’ to ‘1’ transition, which indicates the first data frame bit is received (first data frame bit should be ‘1’). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.STOP_BITS_R.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::STOP_BITS_R struct">STOP_BITS_R</a></td><td class="docblock-short"><p>Field <code>STOP_BITS</code> reader - Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period. Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle (‘1’) time between data frames and the data frame value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.STOP_BITS_W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::STOP_BITS_W struct">STOP_BITS_W</a></td><td class="docblock-short"><p>Field <code>STOP_BITS</code> writer - Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period. Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle (‘1’) time between data frames and the data frame value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.UART_RX_CTRL_SPEC.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::UART_RX_CTRL_SPEC struct">UART_RX_CTRL_SPEC</a></td><td class="docblock-short"><p>UART receiver control</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.W.html" title="psoc6_01_pac::scb0::uart_rx_ctrl::W struct">W</a></td><td class="docblock-short"><p>Register <code>UART_RX_CTRL</code> writer</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="psoc6_01_pac" data-search-index-js="../../../search-index.js" data-search-js="../../../search.js"></div><script src="../../../main.js"></script></body></html>