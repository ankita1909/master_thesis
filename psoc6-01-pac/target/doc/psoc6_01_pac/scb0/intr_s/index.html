<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Slave interrupt request"><meta name="keywords" content="rust, rustlang, rust-lang, intr_s"><title>psoc6_01_pac::scb0::intr_s - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings"></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../psoc6_01_pac/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module intr_s</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li></ul></div><div id="sidebar-vars" data-name="intr_s" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img src="../../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">psoc6_01_pac</a>::<wbr><a href="../index.html">scb0</a>::<wbr><a class="mod" href="#">intr_s</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/psoc6_01_pac/scb0/intr_s.rs.html#1-618" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Slave interrupt request</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.I2C_ACK_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_ACK_R struct">I2C_ACK_R</a></td><td class="docblock-short"><p>Field <code>I2C_ACK</code> reader - I2C slave acknowledgement received. Set to ‘1’, when the slave receives a ACK (typically after the slave transmitted TX data).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_ACK_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_ACK_W struct">I2C_ACK_W</a></td><td class="docblock-short"><p>Field <code>I2C_ACK</code> writer - I2C slave acknowledgement received. Set to ‘1’, when the slave receives a ACK (typically after the slave transmitted TX data).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_ADDR_MATCH_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_ADDR_MATCH_R struct">I2C_ADDR_MATCH_R</a></td><td class="docblock-short"><p>Field <code>I2C_ADDR_MATCH</code> reader - I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is ‘1’) and internally clocked operation (CTRL.EC_OP_MODE is ‘0’), this field is set when the event is detected.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_ADDR_MATCH_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_ADDR_MATCH_W struct">I2C_ADDR_MATCH_W</a></td><td class="docblock-short"><p>Field <code>I2C_ADDR_MATCH</code> writer - I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is ‘1’) and internally clocked operation (CTRL.EC_OP_MODE is ‘0’), this field is set when the event is detected.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_ARB_LOST_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_ARB_LOST_R struct">I2C_ARB_LOST_R</a></td><td class="docblock-short"><p>Field <code>I2C_ARB_LOST</code> reader - I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is ‘1’). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_ARB_LOST_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_ARB_LOST_W struct">I2C_ARB_LOST_W</a></td><td class="docblock-short"><p>Field <code>I2C_ARB_LOST</code> writer - I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is ‘1’). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_BUS_ERROR_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_BUS_ERROR_R struct">I2C_BUS_ERROR_R</a></td><td class="docblock-short"><p>Field <code>I2C_BUS_ERROR</code> reader - I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_BUS_ERROR_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_BUS_ERROR_W struct">I2C_BUS_ERROR_W</a></td><td class="docblock-short"><p>Field <code>I2C_BUS_ERROR</code> writer - I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_GENERAL_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_GENERAL_R struct">I2C_GENERAL_R</a></td><td class="docblock-short"><p>Field <code>I2C_GENERAL</code> reader - I2C slave general call address received. If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is ‘1’) and internally clocked operation (CTRL.EC_OP_MODE is ‘0’), this field is set when the event is detected.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_GENERAL_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_GENERAL_W struct">I2C_GENERAL_W</a></td><td class="docblock-short"><p>Field <code>I2C_GENERAL</code> writer - I2C slave general call address received. If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is ‘1’) and internally clocked operation (CTRL.EC_OP_MODE is ‘0’), this field is set when the event is detected.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_NACK_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_NACK_R struct">I2C_NACK_R</a></td><td class="docblock-short"><p>Field <code>I2C_NACK</code> reader - I2C slave negative acknowledgement received. Set to ‘1’, when the slave receives a NACK (typically after the slave transmitted TX data).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_NACK_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_NACK_W struct">I2C_NACK_W</a></td><td class="docblock-short"><p>Field <code>I2C_NACK</code> writer - I2C slave negative acknowledgement received. Set to ‘1’, when the slave receives a NACK (typically after the slave transmitted TX data).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_START_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_START_R struct">I2C_START_R</a></td><td class="docblock-short"><p>Field <code>I2C_START</code> reader - I2C slave START received. Set to ‘1’, when START or REPEATED START event is detected. In the case of externally clocked address matching (CTRL.EC_AM_MODE is ‘1’) AND clock stretching is performed (till the internally clocked logic takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is ‘0’), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_START_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_START_W struct">I2C_START_W</a></td><td class="docblock-short"><p>Field <code>I2C_START</code> writer - I2C slave START received. Set to ‘1’, when START or REPEATED START event is detected. In the case of externally clocked address matching (CTRL.EC_AM_MODE is ‘1’) AND clock stretching is performed (till the internally clocked logic takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is ‘0’), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_STOP_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_STOP_R struct">I2C_STOP_R</a></td><td class="docblock-short"><p>Field <code>I2C_STOP</code> reader - I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to ‘1’, when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address. The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK’d or NACK’d.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_STOP_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_STOP_W struct">I2C_STOP_W</a></td><td class="docblock-short"><p>Field <code>I2C_STOP</code> writer - I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to ‘1’, when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address. The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK’d or NACK’d.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_WRITE_STOP_R.html" title="psoc6_01_pac::scb0::intr_s::I2C_WRITE_STOP_R struct">I2C_WRITE_STOP_R</a></td><td class="docblock-short"><p>Field <code>I2C_WRITE_STOP</code> reader - I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to ‘1’, when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address. In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK’d or NACK’d. In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.I2C_WRITE_STOP_W.html" title="psoc6_01_pac::scb0::intr_s::I2C_WRITE_STOP_W struct">I2C_WRITE_STOP_W</a></td><td class="docblock-short"><p>Field <code>I2C_WRITE_STOP</code> writer - I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to ‘1’, when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address. In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK’d or NACK’d. In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.INTR_S_SPEC.html" title="psoc6_01_pac::scb0::intr_s::INTR_S_SPEC struct">INTR_S_SPEC</a></td><td class="docblock-short"><p>Slave interrupt request</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.R.html" title="psoc6_01_pac::scb0::intr_s::R struct">R</a></td><td class="docblock-short"><p>Register <code>INTR_S</code> reader</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SPI_BUS_ERROR_R.html" title="psoc6_01_pac::scb0::intr_s::SPI_BUS_ERROR_R struct">SPI_BUS_ERROR_R</a></td><td class="docblock-short"><p>Field <code>SPI_BUS_ERROR</code> reader - SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SPI_BUS_ERROR_W.html" title="psoc6_01_pac::scb0::intr_s::SPI_BUS_ERROR_W struct">SPI_BUS_ERROR_W</a></td><td class="docblock-short"><p>Field <code>SPI_BUS_ERROR</code> writer - SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SPI_EZ_STOP_R.html" title="psoc6_01_pac::scb0::intr_s::SPI_EZ_STOP_R struct">SPI_EZ_STOP_R</a></td><td class="docblock-short"><p>Field <code>SPI_EZ_STOP</code> reader - SPI slave deselected after any EZ SPI transfer occurred.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SPI_EZ_STOP_W.html" title="psoc6_01_pac::scb0::intr_s::SPI_EZ_STOP_W struct">SPI_EZ_STOP_W</a></td><td class="docblock-short"><p>Field <code>SPI_EZ_STOP</code> writer - SPI slave deselected after any EZ SPI transfer occurred.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SPI_EZ_WRITE_STOP_R.html" title="psoc6_01_pac::scb0::intr_s::SPI_EZ_WRITE_STOP_R struct">SPI_EZ_WRITE_STOP_R</a></td><td class="docblock-short"><p>Field <code>SPI_EZ_WRITE_STOP</code> reader - SPI slave deselected after a write EZ SPI transfer occurred.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SPI_EZ_WRITE_STOP_W.html" title="psoc6_01_pac::scb0::intr_s::SPI_EZ_WRITE_STOP_W struct">SPI_EZ_WRITE_STOP_W</a></td><td class="docblock-short"><p>Field <code>SPI_EZ_WRITE_STOP</code> writer - SPI slave deselected after a write EZ SPI transfer occurred.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.W.html" title="psoc6_01_pac::scb0::intr_s::W struct">W</a></td><td class="docblock-short"><p>Register <code>INTR_S</code> writer</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="psoc6_01_pac" data-search-index-js="../../../search-index.js" data-search-js="../../../search.js"></div><script src="../../../main.js"></script></body></html>