initSidebarItems({"struct":[["IDX_R","Field `IDX` reader - The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below. Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is ‘1’."],["IDX_W","Field `IDX` writer - The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below. Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is ‘1’."],["R","Register `STATUS` reader"],["STATUS_SPEC","Fault status"],["VALID_R","Field `VALID` reader - Valid indication: ‘0’: Invalid. ‘1’: Valid. STATUS.IDX, DATA0, …, DATA3 specify the fault. Note: Typically, HW sets this field to ‘1’ (on an activated HW fault source that is ‘enabled’ by the MASK registers) and SW clears this field to ‘0’ (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, …, DATA3 when the VALID field is set to ‘1’. An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to ‘1’ with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds: - STATUS.IDX, DATA0, …, DATA3 can only be written when STATUS.VALID is ‘0’; the fault structure is not in use yet. Writing STATUS.VALID to ‘1’ effectively locks the fault structure (until SW clears STATUS.VALID to ‘0’). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register. Note: For the exceptional SW use case, sequential updates to the DATA and STATUS registers may be ‘interrupted’ by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)"],["VALID_W","Field `VALID` writer - Valid indication: ‘0’: Invalid. ‘1’: Valid. STATUS.IDX, DATA0, …, DATA3 specify the fault. Note: Typically, HW sets this field to ‘1’ (on an activated HW fault source that is ‘enabled’ by the MASK registers) and SW clears this field to ‘0’ (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, …, DATA3 when the VALID field is set to ‘1’. An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to ‘1’ with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds: - STATUS.IDX, DATA0, …, DATA3 can only be written when STATUS.VALID is ‘0’; the fault structure is not in use yet. Writing STATUS.VALID to ‘1’ effectively locks the fault structure (until SW clears STATUS.VALID to ‘0’). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register. Note: For the exceptional SW use case, sequential updates to the DATA and STATUS registers may be ‘interrupted’ by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)"],["W","Register `STATUS` writer"]]});